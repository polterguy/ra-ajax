<h3>Aim of this tutorial</h3>
<ul>
	<li>Help you understand how you can combine Ra-Ajax with ASP.NET Controls and also 3rd Party Controls</li>
	<li>Teach you how to create a minimalistic Ajax GridView application</li>
</ul>

<h3>Prerequisites</h3>
<ul>
	<li>That you have read and understood the previous tutorials in this series</li>
</ul>

<h3>Getting started</h3>
<p>
	One of the real strengths of Ra-Ajax is how well it combines with other control toolkits,
	including the native ASP.NET controls. However when working with Controls which does
	not follow the rendering logic of Ra-Ajax it is important that you know a couple of
	tricks which comes together with Ra-Ajax. Since basically what we're doing is 
	forcing non-Ajax controls to become Ajaxified and play as nice Ajax Citizens.
</p>
<p>
	The first obstacle we will meet when using a non-Ra-Ajax control like the <em>GridView</em>,
	which we are going to use here, is the fact that the ASP.NET GridView cannot render
	within the page rendering logic that Ra-Ajax is built upon. The GridView's <b>only</b> 
	rendering mode is pure HTML. But fear not since for most cases this is actually 
	easy to fix.
</p>

<h3>ReRender to the rescue!</h3>
<p>
	All Ra-Ajax controls have a special method which is called <em>ReRender</em>. This method
	is inherited from <em>RaControl</em>. Normally Ra-Ajax controls doesn't render HTML at
	all back to the client once it has been rendered, but instead JSON is sent back to the
	client with only the attributes that actually changed. When you call the ReRender method
	you signalize to the control that it should bypass this JSON logic and instead work as
	an "UpdatePanel".
</p>
<p>
	When you call ReRender on your Ra-Ajax control, that control will be set to re-render its
	entire HTML back to the client. This means that every child control of the re-rendered
	Ajax Control will also be re-rendered back to the client.
</p>
<p>
	This means that if you have a GridView (or any other non-Ra-Ajax control) which obviously 
	cannot render in the Ra-Ajax rendering logic, you can just wrap this control into any
	Ra-Ajax control, like for instance a Panel. And then every Ajax Callback you want that 
	non-Ajax control to re-render, all you need to do is call <em>ReRender</em> on the parent 
	Ra-Ajax control. This would look something like this...
</p>
<b>.ASPX markup</b>
<pre lang="xml">
<%@ Page 
    Language="C#" 
    AutoEventWireup="true"  
    CodeFile="Default.aspx.cs" 
    Inherits="_Default" %>

<%@ Register 
    Assembly="Ra" 
    Namespace="Ra.Widgets" 
    TagPrefix="ra" %>

<!DOCTYPE html="http://www.w3.org/1999/xhtml">
    <head id="Head1" runat="server">
        <title>Untitled Page</title>
    </head>
    <body>
        <form id="form1" runat="server">
            <div>
                <ra:Panel 
                    runat="server" 
                    ID="pnl">
                    <asp:Button 
                        runat="server" 
                        ID="NONAjaxButton" 
                        Text="Non-Ajax Button" />
                </ra:Panel>
                <ra:Button 
                    runat="server" 
                    ID="btn" 
                    Text="Click me..." 
                    OnClick="btn_Click" />
            </div>
        </form>
    </body>
</html>
</pre>
<b>C# code</b>
<pre lang="cs">
using System;

public partial class _Default : System.Web.UI.Page
{
    protected void btn_Click(object sender, EventArgs e)
    {
        NONAjaxButton.Text = "Howdy world...";
        // If you comment away the next line of code
        // you will NOT see any updates to the ASP.NET 
        // button when the other button is clicked.
        pnl.ReRender();
    }
}
</pre>
<p>
	When you run the above code and click the Ra-Ajax Button, you will see that even
	though this raises a Ra-Ajax Callback, and even though the first button (within the
	panel) is not an Ajax Button, it will still be updated with the new text. Now if you
	comment away the pnl.ReRender() line in the C# code, the button will NOT update.
</p>
<p>
	So as you can see, by putting our non-Ajax controls within any Ra-Ajax control, like
	the Panel we've used above, and using <em>ReRender</em> when it's time to re-render
	the non-Ajax controls on the Panel wrapping them, we can actually create Ajax Citizens 
	out of every non-Ajax controls there is.
</p>
<p>
	<strong>PS!</strong>
	<br />
	There are two limits to this logic, first of all Ra-Ajax will not automagically 
	change those non-Ajax controls to stop doing postbacks and create Ajax Callbacks
	instead. (like ASP.NET UpdatePanels will)
	<br />
	And if those non-Ajax controls includes JavaScript, CSS or some other resource when
	being re-rendered, then those resources will not be included back to the client.
</p>

<h3>Now back to our DataGrid (GridView)</h3>
<p>
	Now that we understands the internals, let us go ahead and create ourselves a
	<em>"Hello Ajax GridView World"</em> example.
</p>

<b>.ASPX markup</b>
<pre lang="xml">
<%@ Page 
    Language="C#" 
    AutoEventWireup="true"  
    CodeFile="Default.aspx.cs" 
    Inherits="_Default" %>

<%@ Register 
    Assembly="Ra" 
    Namespace="Ra.Widgets" 
    TagPrefix="ra" %>

<!DOCTYPE html="http://www.w3.org/1999/xhtml">
    <head id="Head1" runat="server">
        <title>Untitled Page</title>
    </head>
    <body>
        <form id="form1" runat="server">
            <div>
                <ra:Panel 
                    runat="server" 
                    ID="pnl">
                    <asp:GridView 
                        runat="server" 
                        ID="grd">
                        <Columns>
                            <asp:BoundField 
                                DataField="Name" 
                                HeaderText="Name" />
                            <asp:BoundField 
                                DataField="Birthday" 
                                HeaderText="Birthday" />
                        </Columns>
                    </asp:GridView>
                </ra:Panel>
            </div>
        </form>
    </body>
</html>
</pre>

<b>C# code</b>
<pre lang="cs">
using System;
using System.Collections.Generic;
using System.Web;

public class Person
{
    public Person(string name, DateTime birthday)
    {
        Name = name;
        Birthday = birthday;
    }

    public string Name { get; set; }
    public DateTime Birthday { get; set; }

    public static List<Person> People
    {
        get
        {
            if (HttpContext.Current.Session["People"] == null || 
                !(HttpContext.Current.CurrentHandler as System.Web.UI.Page).IsPostBack)
            {
                List<Person> l = new List<Person>();
                l.Add(new Person("John Doe", new DateTime(1974, 5, 16)));
                l.Add(new Person("Jane Doe", new DateTime(1976, 4, 22)));
                HttpContext.Current.Session["People"] = l;
            }
            return HttpContext.Current.Session["People"] as List<Person>;
        }
    }
}

public partial class _Default : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        grd.DataSource = Person.People;
        grd.DataBind();
    }
}
</pre>

<p>
	Now whenever we want to re-render our GridView, all we need to do is call
	the <em>ReRender</em> method on the Panel container like this.
</p>
<pre lang="cs">
pnl.ReRender();
</pre>

<h3>Adding Ajax Filtering</h3>
<p>
	Many times you need to be able to filter your DataGrids. Let us just
	for the fun of it add up a Filtering TextBox to our grid, just like the one which is
	at the top of this webpage to filter classes and tutorials.
</p>
<p>
	Add up just before your panel in your markup this code;
</p>
<pre lang="xml">
<ra:TextBox 
    runat="server" 
    ID="filter" 
    OnKeyUp="filter_KeyUp" />
</pre>
<p>
	And then add this event handler to your C# code...
</p>
<pre lang="cs">
protected void filter_KeyUp(object sender, EventArgs e)
{
    grd.DataSource = Person.People.FindAll(
        delegate(Person idx)
        {
            return idx.Name.ToLower().Contains(filter.Text.ToLower());
        });
    grd.DataBind();

    // IMPORTANT!!
    pnl.ReRender();
}
</pre>

<p>
	Now whenever someone types in anything into the TextBox at the top of the page, 
	the GridView will be filtered and re-rendered back on the client.
</p>

<h3>Complete code</h3>
<p>
	Here is the complete code for this sample for your references.
</p>

<b>.ASPX markup</b>
<pre lang="xml">
<%@ Page 
    Language="C#" 
    AutoEventWireup="true"  
    CodeFile="Default.aspx.cs" 
    Inherits="_Default" %>

<%@ Register 
    Assembly="Ra" 
    Namespace="Ra.Widgets" 
    TagPrefix="ra" %>

<!DOCTYPE html="http://www.w3.org/1999/xhtml">
    <head id="Head1" runat="server">
        <title>Untitled Page</title>
    </head>
    <body>
        <form id="form1" runat="server">
            <div>
                <ra:TextBox 
                    runat="server" 
                    ID="filter" 
                    OnKeyUp="filter_KeyUp" />
                <ra:Panel 
                    runat="server" 
                    ID="pnl">
                    <asp:GridView 
                        runat="server" 
                        ID="grd">
                        <Columns>
                            <asp:BoundField 
                                DataField="Name" 
                                HeaderText="Name" />
                            <asp:BoundField 
                                DataField="Birthday" 
                                HeaderText="Birthday" />
                        </Columns>
                    </asp:GridView>
                </ra:Panel>
            </div>
        </form>
    </body>
</html>
</pre>

<b>C# code</b>
<pre lang="cs">
using System;
using System.Collections.Generic;
using System.Web;

public class Person
{
    public Person(string name, DateTime birthday)
    {
        Name = name;
        Birthday = birthday;
    }

    public string Name { get; set; }
    public DateTime Birthday { get; set; }

    public static List<Person> People
    {
        get
        {
            if (HttpContext.Current.Session["People"] == null || 
                !(HttpContext.Current.CurrentHandler as System.Web.UI.Page).IsPostBack)
            {
                List<Person> l = new List<Person>();
                l.Add(new Person("John Doe", new DateTime(1974, 5, 16)));
                l.Add(new Person("Jane Doe", new DateTime(1976, 4, 22)));
                HttpContext.Current.Session["People"] = l;
            }
            return HttpContext.Current.Session["People"] as List<Person>;
        }
    }
}

public partial class _Default : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        grd.DataSource = Person.People;
        grd.DataBind();
    }

    protected void filter_KeyUp(object sender, EventArgs e)
    {
        grd.DataSource = Person.People.FindAll(
            delegate(Person idx)
            {
                return idx.Name.ToLower().Contains(filter.Text.ToLower());
            });
        grd.DataBind();

        // IMPORTANT!!
        pnl.ReRender();
    }
}
</pre>

<p>
	Next things to explore in regards to a GridView would be how to do CRUD operations
	on a GridView, as in Create new rows, Read existing ones, Update existing ones
	and Delete existing rows in your GridView. But that will be saved for a later article.
</p>




