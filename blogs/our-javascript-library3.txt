How to create an Ajax Library part 3 - Creating a JavaScript Effect class


This is the fourth chapter in our <em>"How to create an Ajax Library"</em> series of articles. If you haven't already you should read <a href="how-to-create-an-ajax-library-part-3-the-element-class-and-the-function.blog">the Element class and the $ function</a> first.

Every JavaScript library with respect for itself will need to have some sort of <em>DHTML JavaScript Effect Library</em> abstractions. These Effects will be used for flashing up and animating parts of the screen when some user interactions are being executed. You can see a sample of these kinds of effects in the <a href="http://script.aculo.us/">ScriptAculous</a> JavaScript library created by my very skilled JavaScript name brother <em>Thomas Fuchs</em>.

The secret behind most JavaScript Effect libraries is that they have two corner stones which they wrap around. The first corner stone is a DOM element and the second is an execution loop which does some kind of change to that DOM Element. Now id we dig really down and think hard about those two issues we can actually vapor away everything else but those two concerns which means that our JavaScript Effect library will be extremely small an lightweight. 

I think that some JavaScript code here is a brilliant way to show what I mean;
<pre>
Ra.Effect = Ra.klass();


Ra.extend(Ra.Effect.prototype, {

  init: function(element, options) {
    this.initEffect(element, options);
  },

  // CTOR implementation to support inheritance 
  // without having to repeat all of this content
  initEffect: function(element, options) {
    this.options = Ra.extend({
      duration: 1.0,
      onStart: function(){},
      onFinished: function(){},
      onRender: null
    }, options || {});
    if( element ) {
      this.element = Ra.$(element);
    }
    this.options.onStart.call(this);
    this.startTime = new Date().getTime();
    this.finishOn = this.startTime + (this.options.duration * 1000);
    this.loop();
  },

  // Called once every 10 millisecond. Heartbeat of animation
  loop: function() {
    var curTime = new Date().getTime();
    if( curTime >= this.finishOn ) {
      this.render(1.0);
      this.options.onFinished.call(this);
    } else {
      // One tick
      var delta = (curTime - this.startTime) / (this.options.duration * 1000);
      this.render(delta);
      var T = this;
      setTimeout(function(){
        T.loop();
      }, 10);
    }
  },

  // Called by loop every 10 milliesond with "position" of animation
  // Position will be a number betweeb 0.0 and 1.0 where 0.0 == beginning and 1.0 == end
  // and anything between the position of the animation meaning if duration == 3 seconds
  // then after 2 seconds the position will equal 0.6666666.
  render: function(pos) {
    this.options.onRender.call(this, pos);
  }
});
</pre>
The above code is really brilliant since with it we can <em>construct any JavaScript Effect we want</em> without forcing our users to a fixed set of Effects. Then later if we want to we can further create abstractions on the server (or in JavaScript) which are more specialized versions of those JavaScript Effects.

Lets say we have a DOM element which have the display style of "none". Then we want to animate that DOM element into visibility by periodically changing its opacity so that it creates the effect of morphing the DOM element into view.

Here's the code to do that;
<pre>
Ra.Effect('someDOMElement' /* id of DOM element */, {
  onStart: function() {
    /* See the <a href="how-to-create-an-ajax-library-part-3-the-element-class-and-the-function.blog">previous article</a> for an explanation of this function */
    this.element.setOpacity(0);
    this.element.style.display = '';
  },
  onFinished: function() {
    this.element.setOpacity(1);
  },
  onRender: function(pos) {
    this.element.setOpacity(pos);
  },
  duration:1.0
});
</pre>
And if we have another DOM Element which we want to "grow" to become 60 pixels in height we can easily do that with this code;
<pre>
Ra.Effect('someOtherDOMElement', {
  onStart: function() {
    this.element.style.height = '0px';
    this.element.style.display = '';
  },
  onFinished: function() {
    this.element.style.height = '60px';
  },
  onRender: function(pos) {
    this.element.style.height = (60*pos) + 'px';
  },
  duration:1.0
});
</pre>
As you can see the above Effect class is making it possible for us to create almost any effects we want to without constraining the user to a certain predefined set of Effects simply by exploiting the two "corner stones of effect classes".


<h3>How it works</h3>
If you take a look at the Effect class one more time you will see that it takes a delegate to a JavaScript function through its "options" argument. This delegate will be called every 10th millisecond with an integer which will have a value between 0.0 and 1.0 depending upon "how far into the effect loop cycle" we currently are. Meaning when 35% of the Effects rendering time have passed the value will be 0.35 and when 70% of the effect rendering time have passed that value will be 0.7 and so on.

In addition the Effect class have a "duration" property and onStart and onFinished functions. The duration is how many seconds the Effect will use for its rendering phase and the onStart and onFinished functions will be called respectively before the effect starts looping and when it is finished looping.

Now whatever you glue into the "loop" delegate through the onRender option is 100% up to you to decide, but basically with these two extremely lightweighted constructs you can create any JavaScript Effect you wish.

Until next time, have a nice day :)


Thomas Hansen



